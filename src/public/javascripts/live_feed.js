// Generated by CoffeeScript 1.4.0
(function() {

  this.LiveFeed = (function() {

    function LiveFeed() {
      this.endpoint = "ws://" + window.location.host + "/websockets";
      this.rowsLimit = 50;
      this.dispatchers = [];
      this.messageRate = 0;
      this.lastMessageTimestamp = null;
    }

    LiveFeed.prototype.onMessage = function(type, data, html) {
      var currentTimestamp;
      console.log(type, data, html);
      _.each(this.dispatchers, (function(dispatcher) {
        return dispatcher(data);
      }));
      currentTimestamp = Math.round(new Date() / 1000);
      if (this.lastMessageTimestamp && this.lastMessageTimestamp === currentTimestamp) {
        this.messageRate += 1;
      } else {
        if (typeof console !== "undefined" && console !== null) {
          console.log(this.messageRate, data.received_at);
        }
        this.messageRate = 1;
      }
      return this.lastMessageTimestamp = currentTimestamp;
    };

    LiveFeed.prototype.addDispatcher = function(dispatcher) {
      return this.dispatchers.push(dispatcher);
    };

    LiveFeed.prototype.dispatchMessage = function(evt) {
      var payload;
      payload = JSON.parse(evt.data);
      return this.onMessage(payload.type, payload.data, payload.html);
    };

    LiveFeed.prototype.watch = function() {
      this.socket = new WebSocket(this.endpoint);
      return this.socket.onmessage = this.dispatchMessage.bind(this);
    };

    LiveFeed.prototype.maybePruneLastRow = function() {
      var lastRow;
      if (this.getRowCount() > this.rowsLimit) {
        lastRow = this.tbody.getElements("tr").getLast();
        if (lastRow !== void 0) {
          return lastRow.destroy();
        }
      }
    };

    LiveFeed.prototype.getRowCount = function(tbody) {
      return this.element.getElementsByTagName("tbody")[0].getElementsByTagName("tr").length;
    };

    return LiveFeed;

  })();

  $(function() {
    var attrs, feed, graph_config, stats;
    if ($("#graphs").length > 0) {
      feed = new LiveFeed();
      feed.watch();
      stats = JSON.parse($("#stats").val());
      $("#graphs").append($("<h3>Performance data</h3>"));
      attrs = {
        x: {
          caption: "Last 400 data points"
        },
        y: {
          caption: "Response time, seconds"
        },
        buffer_size: 400
      };
      graph_config = {
        feed: feed,
        filter: (function(data) {
          return data.type === "page_load";
        }),
        extractor: (function(data) {
          return {
            y: data.additional_info.execution_time,
            complete_info: data
          };
        })
      };
      new Eventoverse.Graphs.RealTimeCanvas("#graphs", attrs).addElement(Eventoverse.Graphs.RealTimeLine, graph_config).addElement(Eventoverse.Graphs.Controls, {
        tip_formatter: function(d) {
          return "<dl><dt>Received At</dt><dd>" + d.complete_info.received_at + "</dd><dt>URL</dt><dd>" + d.complete_info.additional_info.url + "</dd><dt>Host</dt><dd>" + d.complete_info.hostname + "</dd><dt>Status</dt><dd>" + d.complete_info.additional_info.status + "</dd><dt>Time (sec)</dt><dd>" + d.complete_info.additional_info.execution_time + "</dd><dt>User Agent</dt><dd>" + d.complete_info.additional_info.user_agent + "</dd></dl>";
        }
      }).render({
        values: d3.range(400).map(function() {
          return {
            y: 0,
            complete_info: {}
          };
        })
      });
      return _.each(stats.hosts, function(host) {
        $("#graphs").append($("<h3>Memory on " + host + "</h3>"));
        attrs = {
          x: {
            caption: "Last 400 data points"
          },
          y: {
            caption: "Memory (GB)"
          },
          buffer_size: 400
        };
        graph_config = {
          feed: feed,
          filter: (function(data) {
            return data.type === "memory_usage" && data.hostname === host;
          }),
          extractor: (function(data) {
            return {
              y: data.additional_info.HeapMemoryUsage.used / 1000000000,
              complete_info: data
            };
          })
        };
        return new Eventoverse.Graphs.RealTimeCanvas("#graphs", attrs).addElement(Eventoverse.Graphs.RealTimeLine, graph_config).addElement(Eventoverse.Graphs.Controls, {
          tip_formatter: function(d) {
            return "<dl><dt>Received At</dt><dd>" + d.complete_info.received_at + "</dd><dt>Memory(heap): </dt><dd>" + d.complete_info.additional_info.HeapMemoryUsage.used + "</dd><dt>Memory(non-heap): </dt><dd>" + d.complete_info.additional_info.NonHeapMemoryUsage.used + "</dd></dl>";
          }
        }).render({
          values: d3.range(400).map(function() {
            return {
              y: 0,
              complete_info: {}
            };
          })
        });
      });
    }
  });

}).call(this);
